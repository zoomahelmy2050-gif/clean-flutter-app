import 'dart:async';
import 'dart:convert';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';

enum VulnerabilitySeverity {
  info,
  low,
  medium,
  high,
  critical,
}

enum VulnerabilityCategory {
  authentication,
  authorization,
  dataValidation,
  cryptography,
  sessionManagement,
  configuration,
  dependency,
  injection,
  xss,
  csrf,
}

enum ScanType {
  quick,
  comprehensive,
  targeted,
  compliance,
}

class Vulnerability {
  final String id;
  final String title;
  final String description;
  final VulnerabilitySeverity severity;
  final VulnerabilityCategory category;
  final String component;
  final DateTime discoveredAt;
  final String? cveId;
  final double cvssScore;
  final List<String> affectedVersions;
  final String? fixedVersion;
  final List<String> recommendations;
  final Map<String, dynamic> evidence;
  final bool falsePositive;
  final DateTime? resolvedAt;

  Vulnerability({
    required this.id,
    required this.title,
    required this.description,
    required this.severity,
    required this.category,
    required this.component,
    required this.discoveredAt,
    this.cveId,
    required this.cvssScore,
    this.affectedVersions = const [],
    this.fixedVersion,
    this.recommendations = const [],
    this.evidence = const {},
    this.falsePositive = false,
    this.resolvedAt,
  });

  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'description': description,
    'severity': severity.name,
    'category': category.name,
    'component': component,
    'discoveredAt': discoveredAt.toIso8601String(),
    'cveId': cveId,
    'cvssScore': cvssScore,
    'affectedVersions': affectedVersions,
    'fixedVersion': fixedVersion,
    'recommendations': recommendations,
    'evidence': evidence,
    'falsePositive': falsePositive,
    'resolvedAt': resolvedAt?.toIso8601String(),
  };

  factory Vulnerability.fromJson(Map<String, dynamic> json) {
    return Vulnerability(
      id: json['id'],
      title: json['title'],
      description: json['description'],
      severity: VulnerabilitySeverity.values.firstWhere((e) => e.name == json['severity']),
      category: VulnerabilityCategory.values.firstWhere((e) => e.name == json['category']),
      component: json['component'],
      discoveredAt: DateTime.parse(json['discoveredAt']),
      cveId: json['cveId'],
      cvssScore: json['cvssScore'].toDouble(),
      affectedVersions: List<String>.from(json['affectedVersions'] ?? []),
      fixedVersion: json['fixedVersion'],
      recommendations: List<String>.from(json['recommendations'] ?? []),
      evidence: Map<String, dynamic>.from(json['evidence'] ?? {}),
      falsePositive: json['falsePositive'] ?? false,
      resolvedAt: json['resolvedAt'] != null ? DateTime.parse(json['resolvedAt']) : null,
    );
  }
}

class SecurityScan {
  final String id;
  final ScanType type;
  final DateTime startTime;
  final DateTime? endTime;
  final Duration? duration;
  final List<String> scannedComponents;
  final int vulnerabilitiesFound;
  final Map<VulnerabilitySeverity, int> severityBreakdown;
  final double securityScore;
  final Map<String, dynamic> scanConfig;
  final List<String> vulnerabilityIds;

  SecurityScan({
    required this.id,
    required this.type,
    required this.startTime,
    this.endTime,
    this.duration,
    required this.scannedComponents,
    required this.vulnerabilitiesFound,
    required this.severityBreakdown,
    required this.securityScore,
    this.scanConfig = const {},
    this.vulnerabilityIds = const [],
  });

  Map<String, dynamic> toJson() => {
    'id': id,
    'type': type.name,
    'startTime': startTime.toIso8601String(),
    'endTime': endTime?.toIso8601String(),
    'duration': duration?.inMilliseconds,
    'scannedComponents': scannedComponents,
    'vulnerabilitiesFound': vulnerabilitiesFound,
    'severityBreakdown': severityBreakdown.map((k, v) => MapEntry(k.name, v)),
    'securityScore': securityScore,
    'scanConfig': scanConfig,
    'vulnerabilityIds': vulnerabilityIds,
  };

  factory SecurityScan.fromJson(Map<String, dynamic> json) {
    final severityMap = <VulnerabilitySeverity, int>{};
    (json['severityBreakdown'] as Map<String, dynamic>).forEach((key, value) {
      final severity = VulnerabilitySeverity.values.firstWhere((e) => e.name == key);
      severityMap[severity] = value;
    });

    return SecurityScan(
      id: json['id'],
      type: ScanType.values.firstWhere((e) => e.name == json['type']),
      startTime: DateTime.parse(json['startTime']),
      endTime: json['endTime'] != null ? DateTime.parse(json['endTime']) : null,
      duration: json['duration'] != null ? Duration(milliseconds: json['duration']) : null,
      scannedComponents: List<String>.from(json['scannedComponents']),
      vulnerabilitiesFound: json['vulnerabilitiesFound'],
      severityBreakdown: severityMap,
      securityScore: json['securityScore'].toDouble(),
      scanConfig: Map<String, dynamic>.from(json['scanConfig'] ?? {}),
      vulnerabilityIds: List<String>.from(json['vulnerabilityIds'] ?? []),
    );
  }
}

class VulnerabilityScanningService extends ChangeNotifier {
  final List<Vulnerability> _vulnerabilities = [];
  final List<SecurityScan> _scans = [];
  Timer? _scheduledScanTimer;
  bool _isScanning = false;
  
  static const String _vulnerabilitiesKey = 'vulnerabilities';
  static const String _scansKey = 'security_scans';

  // Getters
  List<Vulnerability> get vulnerabilities => List.unmodifiable(_vulnerabilities);
  List<SecurityScan> get scans => List.unmodifiable(_scans);
  bool get isScanning => _isScanning;
  
  List<Vulnerability> get activeVulnerabilities => 
    _vulnerabilities.where((v) => v.resolvedAt == null && !v.falsePositive).toList();

  /// Initialize vulnerability scanning service
  Future<void> initialize() async {
    await _loadVulnerabilities();
    await _loadScans();
    await _startScheduledScanning();
  }

  /// Load vulnerabilities from storage
  Future<void> _loadVulnerabilities() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final vulnerabilitiesJson = prefs.getStringList(_vulnerabilitiesKey) ?? [];
      
      _vulnerabilities.clear();
      for (final vulnJson in vulnerabilitiesJson) {
        final Map<String, dynamic> data = jsonDecode(vulnJson);
        _vulnerabilities.add(Vulnerability.fromJson(data));
      }
    } catch (e) {
      debugPrint('Error loading vulnerabilities: $e');
    }
  }

  /// Save vulnerabilities to storage
  Future<void> _saveVulnerabilities() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final vulnerabilitiesJson = _vulnerabilities.map((v) => jsonEncode(v.toJson())).toList();
      await prefs.setStringList(_vulnerabilitiesKey, vulnerabilitiesJson);
    } catch (e) {
      debugPrint('Error saving vulnerabilities: $e');
    }
  }

  /// Load scans from storage
  Future<void> _loadScans() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final scansJson = prefs.getStringList(_scansKey) ?? [];
      
      _scans.clear();
      for (final scanJson in scansJson) {
        final Map<String, dynamic> data = jsonDecode(scanJson);
        _scans.add(SecurityScan.fromJson(data));
      }
    } catch (e) {
      debugPrint('Error loading security scans: $e');
    }
  }

  /// Save scans to storage
  Future<void> _saveScans() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final scansJson = _scans.map((s) => jsonEncode(s.toJson())).toList();
      await prefs.setStringList(_scansKey, scansJson);
    } catch (e) {
      debugPrint('Error saving security scans: $e');
    }
  }

  /// Start scheduled scanning
  Future<void> _startScheduledScanning() async {
    // Run daily scans
    _scheduledScanTimer = Timer.periodic(const Duration(hours: 24), (_) {
      performScan(ScanType.quick);
    });
  }

  /// Perform security scan
  Future<String> performScan(ScanType scanType, {
    List<String>? targetComponents,
    Map<String, dynamic>? config,
  }) async {
    if (_isScanning) {
      throw Exception('Scan already in progress');
    }

    _isScanning = true;
    notifyListeners();

    final scanId = 'scan_${DateTime.now().millisecondsSinceEpoch}';
    final startTime = DateTime.now();
    
    try {
      final components = targetComponents ?? _getDefaultComponents();
      final scanConfig = config ?? _getDefaultScanConfig(scanType);
      
      debugPrint('Starting $scanType scan with ID: $scanId');
      
      // Simulate scan duration based on type
      final scanDuration = _getScanDuration(scanType);
      await Future.delayed(scanDuration);
      
      // Perform actual scanning
      final foundVulnerabilities = await _performActualScan(scanType, components, scanConfig);
      
      final endTime = DateTime.now();
      final duration = endTime.difference(startTime);
      
      // Calculate security score
      final securityScore = _calculateSecurityScore(foundVulnerabilities);
      
      // Create severity breakdown
      final severityBreakdown = <VulnerabilitySeverity, int>{};
      for (final severity in VulnerabilitySeverity.values) {
        severityBreakdown[severity] = foundVulnerabilities.where((v) => v.severity == severity).length;
      }
      
      final scan = SecurityScan(
        id: scanId,
        type: scanType,
        startTime: startTime,
        endTime: endTime,
        duration: duration,
        scannedComponents: components,
        vulnerabilitiesFound: foundVulnerabilities.length,
        severityBreakdown: severityBreakdown,
        securityScore: securityScore,
        scanConfig: scanConfig,
        vulnerabilityIds: foundVulnerabilities.map((v) => v.id).toList(),
      );
      
      _scans.insert(0, scan);
      
      // Keep only last 50 scans
      if (_scans.length > 50) {
        _scans.removeRange(50, _scans.length);
      }
      
      await _saveScans();
      
      debugPrint('Scan completed. Found ${foundVulnerabilities.length} vulnerabilities. Security score: $securityScore');
      
      return scanId;
      
    } finally {
      _isScanning = false;
      notifyListeners();
    }
  }

  /// Get default components to scan
  List<String> _getDefaultComponents() {
    return [
      'Authentication System',
      'Session Management',
      'Data Validation',
      'Cryptography',
      'API Endpoints',
      'Database Layer',
      'File System',
      'Network Layer',
      'Dependencies',
      'Configuration',
    ];
  }

  /// Get default scan configuration
  Map<String, dynamic> _getDefaultScanConfig(ScanType scanType) {
    switch (scanType) {
      case ScanType.quick:
        return {
          'depth': 'shallow',
          'timeout': 300, // 5 minutes
          'aggressive': false,
        };
      case ScanType.comprehensive:
        return {
          'depth': 'deep',
          'timeout': 3600, // 1 hour
          'aggressive': true,
        };
      case ScanType.targeted:
        return {
          'depth': 'medium',
          'timeout': 900, // 15 minutes
          'aggressive': false,
        };
      case ScanType.compliance:
        return {
          'depth': 'compliance',
          'timeout': 1800, // 30 minutes
          'aggressive': false,
          'standards': ['OWASP', 'NIST', 'ISO27001'],
        };
    }
  }

  /// Get scan duration based on type
  Duration _getScanDuration(ScanType scanType) {
    switch (scanType) {
      case ScanType.quick:
        return const Duration(seconds: 30);
      case ScanType.comprehensive:
        return const Duration(minutes: 2);
      case ScanType.targeted:
        return const Duration(seconds: 45);
      case ScanType.compliance:
        return const Duration(minutes: 1);
    }
  }

  /// Perform actual scanning (simulated)
  Future<List<Vulnerability>> _performActualScan(
    ScanType scanType,
    List<String> components,
    Map<String, dynamic> config,
  ) async {
    final random = Random();
    final foundVulnerabilities = <Vulnerability>[];
    
    // Simulate finding vulnerabilities based on scan type
    final vulnCount = _getExpectedVulnerabilityCount(scanType);
    
    for (int i = 0; i < vulnCount; i++) {
      final vulnerability = _generateSimulatedVulnerability(components[random.nextInt(components.length)]);
      foundVulnerabilities.add(vulnerability);
      
      // Add to main vulnerabilities list if not already present
      if (!_vulnerabilities.any((v) => v.id == vulnerability.id)) {
        _vulnerabilities.insert(0, vulnerability);
      }
    }
    
    // Keep only last 1000 vulnerabilities
    if (_vulnerabilities.length > 1000) {
      _vulnerabilities.removeRange(1000, _vulnerabilities.length);
    }
    
    await _saveVulnerabilities();
    
    return foundVulnerabilities;
  }

  /// Get expected vulnerability count based on scan type
  int _getExpectedVulnerabilityCount(ScanType scanType) {
    final random = Random();
    switch (scanType) {
      case ScanType.quick:
        return random.nextInt(5); // 0-4 vulnerabilities
      case ScanType.comprehensive:
        return random.nextInt(15) + 5; // 5-19 vulnerabilities
      case ScanType.targeted:
        return random.nextInt(8) + 2; // 2-9 vulnerabilities
      case ScanType.compliance:
        return random.nextInt(10) + 3; // 3-12 vulnerabilities
    }
  }

  /// Generate simulated vulnerability
  Vulnerability _generateSimulatedVulnerability(String component) {
    final random = Random();
    final severities = VulnerabilitySeverity.values;
    final categories = VulnerabilityCategory.values;
    
    final severity = severities[random.nextInt(severities.length)];
    final category = categories[random.nextInt(categories.length)];
    
    final vulnerabilityTemplates = _getVulnerabilityTemplates();
    final template = vulnerabilityTemplates[category] ?? vulnerabilityTemplates.values.first;
    
    return Vulnerability(
      id: 'vuln_${DateTime.now().millisecondsSinceEpoch}_${random.nextInt(1000)}',
      title: template['title'] as String,
      description: template['description'] as String,
      severity: severity,
      category: category,
      component: component,
      discoveredAt: DateTime.now(),
      cveId: random.nextBool() ? 'CVE-2024-${random.nextInt(9999).toString().padLeft(4, '0')}' : null,
      cvssScore: _generateCvssScore(severity),
      recommendations: List<String>.from(template['recommendations'] as List),
      evidence: {
        'scan_method': 'automated',
        'confidence': random.nextDouble(),
        'false_positive_probability': random.nextDouble() * 0.3,
      },
    );
  }

  /// Get vulnerability templates
  Map<VulnerabilityCategory, Map<String, dynamic>> _getVulnerabilityTemplates() {
    return {
      VulnerabilityCategory.authentication: {
        'title': 'Weak Authentication Mechanism',
        'description': 'Authentication system may be vulnerable to brute force or credential stuffing attacks',
        'recommendations': [
          'Implement account lockout policies',
          'Add CAPTCHA after failed attempts',
          'Enforce strong password policies',
          'Implement multi-factor authentication',
        ],
      },
      VulnerabilityCategory.authorization: {
        'title': 'Insufficient Access Controls',
        'description': 'Authorization checks may be bypassed or insufficient',
        'recommendations': [
          'Implement principle of least privilege',
          'Add proper role-based access controls',
          'Validate permissions on all endpoints',
          'Regular access reviews',
        ],
      },
      VulnerabilityCategory.dataValidation: {
        'title': 'Input Validation Weakness',
        'description': 'User input is not properly validated or sanitized',
        'recommendations': [
          'Implement server-side validation',
          'Use parameterized queries',
          'Sanitize all user inputs',
          'Implement input length limits',
        ],
      },
      VulnerabilityCategory.cryptography: {
        'title': 'Cryptographic Weakness',
        'description': 'Weak or outdated cryptographic algorithms in use',
        'recommendations': [
          'Use strong encryption algorithms',
          'Implement proper key management',
          'Use secure random number generation',
          'Regular cryptographic reviews',
        ],
      },
      VulnerabilityCategory.sessionManagement: {
        'title': 'Session Management Flaw',
        'description': 'Session tokens may be predictable or improperly managed',
        'recommendations': [
          'Use secure session token generation',
          'Implement proper session timeout',
          'Secure session storage',
          'Session fixation protection',
        ],
      },
    };
  }

  /// Generate CVSS score based on severity
  double _generateCvssScore(VulnerabilitySeverity severity) {
    final random = Random();
    switch (severity) {
      case VulnerabilitySeverity.info:
        return 0.0;
      case VulnerabilitySeverity.low:
        return 0.1 + random.nextDouble() * 3.8; // 0.1-3.9
      case VulnerabilitySeverity.medium:
        return 4.0 + random.nextDouble() * 2.9; // 4.0-6.9
      case VulnerabilitySeverity.high:
        return 7.0 + random.nextDouble() * 1.9; // 7.0-8.9
      case VulnerabilitySeverity.critical:
        return 9.0 + random.nextDouble() * 1.0; // 9.0-10.0
    }
  }

  /// Calculate security score
  double _calculateSecurityScore(List<Vulnerability> vulnerabilities) {
    if (vulnerabilities.isEmpty) return 100.0;
    
    double score = 100.0;
    
    for (final vuln in vulnerabilities) {
      switch (vuln.severity) {
        case VulnerabilitySeverity.critical:
          score -= 20.0;
          break;
        case VulnerabilitySeverity.high:
          score -= 10.0;
          break;
        case VulnerabilitySeverity.medium:
          score -= 5.0;
          break;
        case VulnerabilitySeverity.low:
          score -= 2.0;
          break;
        case VulnerabilitySeverity.info:
          score -= 0.5;
          break;
      }
    }
    
    return (score < 0) ? 0.0 : score;
  }

  /// Mark vulnerability as false positive
  Future<void> markAsFalsePositive(String vulnerabilityId) async {
    final index = _vulnerabilities.indexWhere((v) => v.id == vulnerabilityId);
    if (index != -1) {
      final vuln = _vulnerabilities[index];
      _vulnerabilities[index] = Vulnerability(
        id: vuln.id,
        title: vuln.title,
        description: vuln.description,
        severity: vuln.severity,
        category: vuln.category,
        component: vuln.component,
        discoveredAt: vuln.discoveredAt,
        cveId: vuln.cveId,
        cvssScore: vuln.cvssScore,
        affectedVersions: vuln.affectedVersions,
        fixedVersion: vuln.fixedVersion,
        recommendations: vuln.recommendations,
        evidence: vuln.evidence,
        falsePositive: true,
        resolvedAt: vuln.resolvedAt,
      );
      
      await _saveVulnerabilities();
      notifyListeners();
    }
  }

  /// Resolve vulnerability
  Future<void> resolveVulnerability(String vulnerabilityId) async {
    final index = _vulnerabilities.indexWhere((v) => v.id == vulnerabilityId);
    if (index != -1) {
      final vuln = _vulnerabilities[index];
      _vulnerabilities[index] = Vulnerability(
        id: vuln.id,
        title: vuln.title,
        description: vuln.description,
        severity: vuln.severity,
        category: vuln.category,
        component: vuln.component,
        discoveredAt: vuln.discoveredAt,
        cveId: vuln.cveId,
        cvssScore: vuln.cvssScore,
        affectedVersions: vuln.affectedVersions,
        fixedVersion: vuln.fixedVersion,
        recommendations: vuln.recommendations,
        evidence: vuln.evidence,
        falsePositive: vuln.falsePositive,
        resolvedAt: DateTime.now(),
      );
      
      await _saveVulnerabilities();
      notifyListeners();
    }
  }

  /// Get vulnerability statistics
  Map<String, dynamic> getVulnerabilityStatistics() {
    final totalVulns = _vulnerabilities.length;
    final activeVulns = activeVulnerabilities.length;
    final resolvedVulns = _vulnerabilities.where((v) => v.resolvedAt != null).length;
    final falsePositives = _vulnerabilities.where((v) => v.falsePositive).length;
    
    final severityBreakdown = <String, int>{};
    for (final severity in VulnerabilitySeverity.values) {
      severityBreakdown[severity.name] = activeVulnerabilities.where((v) => v.severity == severity).length;
    }
    
    final categoryBreakdown = <String, int>{};
    for (final category in VulnerabilityCategory.values) {
      categoryBreakdown[category.name] = activeVulnerabilities.where((v) => v.category == category).length;
    }
    
    // Calculate current security score
    final currentSecurityScore = _calculateSecurityScore(activeVulnerabilities);
    
    return {
      'total_vulnerabilities': totalVulns,
      'active_vulnerabilities': activeVulns,
      'resolved_vulnerabilities': resolvedVulns,
      'false_positives': falsePositives,
      'current_security_score': currentSecurityScore,
      'severity_breakdown': severityBreakdown,
      'category_breakdown': categoryBreakdown,
      'total_scans': _scans.length,
      'last_scan': _scans.isNotEmpty ? _scans.first.startTime.toIso8601String() : null,
      'scan_trends': _getScanTrends(),
    };
  }

  /// Get scan trends
  Map<String, dynamic> _getScanTrends() {
    if (_scans.isEmpty) return {};
    
    final last7Scans = _scans.take(7).toList();
    final securityScores = last7Scans.map((s) => s.securityScore).toList();
    final vulnerabilityCounts = last7Scans.map((s) => s.vulnerabilitiesFound).toList();
    
    return {
      'security_scores': securityScores,
      'vulnerability_counts': vulnerabilityCounts,
      'average_security_score': securityScores.isEmpty ? 0.0 : securityScores.reduce((a, b) => a + b) / securityScores.length,
      'trend_direction': _calculateTrend(securityScores),
    };
  }

  /// Calculate trend direction
  String _calculateTrend(List<double> scores) {
    if (scores.length < 2) return 'stable';
    
    final recent = scores.take(3).toList();
    final older = scores.skip(3).take(3).toList();
    
    if (recent.isEmpty || older.isEmpty) return 'stable';
    
    final recentAvg = recent.reduce((a, b) => a + b) / recent.length;
    final olderAvg = older.reduce((a, b) => a + b) / older.length;
    
    if (recentAvg > olderAvg + 5) return 'improving';
    if (recentAvg < olderAvg - 5) return 'declining';
    return 'stable';
  }

  /// Export vulnerability data
  Map<String, dynamic> exportVulnerabilityData() {
    return {
      'vulnerabilities': _vulnerabilities.map((v) => v.toJson()).toList(),
      'scans': _scans.map((s) => s.toJson()).toList(),
      'statistics': getVulnerabilityStatistics(),
      'exported_at': DateTime.now().toIso8601String(),
    };
  }

  @override
  void dispose() {
    _scheduledScanTimer?.cancel();
    super.dispose();
  }
}
